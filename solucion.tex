\chapter{Solución}

\section{Arquitectura}

La solución es una librería de Python para generar visualizaciones animadas de estructuras de datos y las operaciones que se realizan sobre estas, que pueda ser usada en Jupyter Notebooks.

La librería le permite al usuario implementar una estructura de datos y, agregando la instrumentación provista por la librería, le permite generar una visualización animada de las operaciones que se realizaron sobre la estructura.

Para permitir esto la librería está compuesta por dos partes: el \textit{back-end} y el \textit{front-end}. Estas dos partes se comunican entre sí utilizando un modelo de datos común que cada una de las partes sabe serializar y deserializar.

\begin{figure}[htb]
    \centering
    \includesvg[width=\textwidth]{imagenes/diagramas/arquitectura.svg}
    \caption{Diagrama de la arquitectura}
    \label{fig:diagrama-arq}
\end{figure}

El \textit{back-end}, implementado en Python, define la instrumentación para capturar las operaciones realizadas sobre la estructura de datos. Se encarga de mantener un registro de todas las operaciones que se realizan sobre esta. Este registro se mantiene utilizando una representación de las operaciones primitivas sobre la estructura de datos. Teniendo esto, cuando un usuario quiere generar la visualización, este registro de operaciones es serializado y enviado al \textit{front-end}. Esto se logra utilizando usando la librería IPython Widgets en combinación con el serializador definido para el modelo.

El \textit{front-end}, implementado en TypeScript, recibe el modelo serializado, deserializa el modelo y genera la visualización a partir de este. Para generar la visualización utiliza la librería D3js, que permite manipular el DOM (Document Object Model) en función de los datos del modelo.

La figura~\ref{fig:flujo-informacion} es un diagrama que muestra el flujo de la información cuando se utiliza la herramienta. Primero el usuario implementa y usa la estructura de datos en el notebook, después a partir de esto se genera un registro en el back-end, luego este registro se sincroniza con el front-end y finalmente este último genera la animación en el navegador.

\begin{figure}[htb]
    \centering
    \includesvg[pretex=\footnotesize,width=\textwidth]{imagenes/diagramas/diagrama-de-flujo.svg}
    \caption{Flujo de la información}
    \label{fig:flujo-informacion}
\end{figure}

En la figura~\ref{fig:diagrama-arq} se puede ver un diagrama que representa la arquitectura física de la solución. El usuario interactúa con la herramienta usando el navegador, donde corre el front-end. Este se comunica usando HTTP y Websockets con el servidor de Notebooks, que se encarga de interactuar con el archivo del Notebook y se comunica con el kernel usando ZeroMQ ---una librería de comunicación asíncrona orientada a mensajes---. El kernel contiene el intérprete de Python y es donde corre el back-end de la herramienta.

\section{Modelo de datos}

Cuando un usuario quiere generar una visualización el back-end le envía al front-end una representación de las operaciones realizadas sobre la estructura de datos. Para esto se diseñó un modelo que representa las operaciones primitivas que se pueden realizar sobre las listas enlazadas. Además, el modelo contiene metadatos que son útiles para generar la visualización.

El modelo que se utiliza para generar la visualización consiste en una lista de operaciones y metadatos de la visualización. Cada operación consiste en una operación primitiva y metadatos de la operación.

Las operaciones primitivas son las siguientes:
\begin{itemize}
    \item{\makebox[3.5cm]{Init(id, value, next)\hfill}}: Inicializar un nodo
    \item{\makebox[3.5cm]{SetValue(id, value)\hfill}}: Asignar el valor de un nodo
    \item{\makebox[3.5cm]{GetValue(id)\hfill}}: Obtener el valor de un nodo
    \item{\makebox[3.5cm]{SetNext(id, next)\hfill}}: Asignar el siguiente de un nodo
    \item{\makebox[3.5cm]{GetNext(id)\hfill}}: Obtener el siguiente de un nodo
\end{itemize}
donde \textit{id} es el identificador único de cada nodo, \textit{value} es una cadena de texto que representa el valor del nodo y \textit{next} es el identificador del siguiente nodo en la lista enlazada o es \textit{null}.

Los metadatos de la visualización son configuraciones de la visualización, por ejemplo, la duración de las transiciones y la duración de los fade-ins y fade-outs. En cambio, los metadatos de las operaciones contienen información que solo es relevante para esa operación, por ejemplo, si se debe animar o no esa operación y el código fuente que dio origen a la operación.

En la figura~\ref{fig:codigo-vs-modelo} se puede ver un ejemplo de código fuente que usa la herramienta, una captura de la animación generada a partir de ese código y el modelo generado a partir del código que se usa para crear la visualización.

\begin{figure}[p]
    \centering
    \begin{subfigure}[b]{0.49\textwidth}
        \centering
        \begin{minted}[linenos=false,fontsize=\scriptsize]{python}
@node('value', 'next')
class Node:
    def __init__(self, value, next=None):
        self.value = value
        self.next = next

@container(lines_before=0, lines_after=0)
class List:
    def __init__(self):
        self.node = None
        
    def append(self, value):
        node = self.node
        if node is None:
            self.node = Node(value, None)
            return

        next = node.next
        while next is not None:
            node = next
            next = next.next
        node.next = Node(value, None)

l = List()
l.append(1)
l.append(2)
l.visualize()
        \end{minted}
        \caption{Código}
        \label{fig:codigo-vs-modelo:codigo}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{imagenes/codigo-imagen-modelo.png}
        \caption{Captura de la visualización}
        \label{fig:codigo-vs-modelo:imagen}
    \end{subfigure}
    \begin{subfigure}[b]{0.8\textwidth}
        \centering
        \begin{minted}[linenos=false,fontsize=\scriptsize]{json}
{
  "operations": [
    {
      "operation": { "operation": "init", "id": 6, "value": "1", "next": null },
      "metadata": {
        "animate": true,
        "source": ["l.append(1)\n", "> 15     self.node = Node(value, None)\n"]
      }
    },
    {
      "operation": { "operation": "get_next", "id": 6 },
      "metadata": {
        "animate": true,
        "source": ["l.append(2)\n", "> 18 next = node.next\n"]
      }
    },
    {
      "operation": { "operation": "init", "id": 7, "value": "2", "next": null },
      "metadata": {
        "animate": true,
        "source": ["l.append(2)\n", "> 22 node.next = Node(value, None)\n"]
      }
    },
    {
      "operation": { "operation": "set_next", "id": 6, "next": 7 },
      "metadata": {
        "animate": true,
        "source": ["l.append(2)\n", "> 22 node.next = Node(value, None)\n"]
      }
    }
  ],
  "metadata": { "transition_duration": 1000, "fade_in_duration": 1000 }
}
                      
        \end{minted}
        \caption{Modelo generado a partir del código}
        \label{fig:codigo-vs-modelo:modelo}
    \end{subfigure}
    \caption{Código, captura de la visualización y modelo}
    \label{fig:codigo-vs-modelo}
\end{figure}

Este modelo en realidad representa un grafo dirigido con un grado máximo de 1. Este nivel de flexibilidad es necesario porque como la representación se genera a partir de un programa escrito por el usuario, este puede contener errores que hagan que la estructura de datos implementada no sea necesariamente una lista enlazada. Por ejemplo, por ejemplo, el usuario puede crear nodos que no estén conectados entre sí y puede crear ciclos.

Para una versión futura de la herramienta se podría cambiar esta representación para que represente grafos sin un grado máximo. Esto permitiría representar estructuras de datos tales como grafos, árboles y listas enlazadas. Se consideró utilizar esta representación desde un principio, pero no se hizo porque dificultaba la generación de la visualización para la estructura de datos abordada.

\section{Back-end}

El back-end se encarga de proveer la instrumentación necesaria para que el usuario pueda generar visualizaciones de las estructuras de datos que ha implementado. Usando esta instrumentación mantiene un registro de las operaciones primitivas realizadas sobre la estructura de datos y cuando el usuario quiere visualizar el resultado serializa este registro y lo envía al \textit{front-end}.

Para esto la librería provee dos \textit{decoradores} ---azúcar sintáctica de Python para aplicar funciones a las definiciones de clases o funciones--- \textit{node} y \textit{container}. El primero de estos denota la clase que representa el nodo de la lista enlazada, mientras que el segundo denota la clase que contiene una referencia al primer nodo de la lista. En el código~\ref{lst:ejemplo-uso} se puede ver un ejemplo del uso de estos decoradores y en la figura~\ref{fig:visualizacion_ej} se puede ver un cuadro de la visualización generada.

\begin{listing}[htb]
\caption{Ejemplo de uso de la librería}
\label{lst:ejemplo-uso}
\begin{minted}[linenos=true]{python}
from dsvisualizer import node, container

@node('hd', 'tl')
class Node():
    def __init__(self, hd, tl):
        self.hd = hd
        self.tl = tl

@container()
class List():
    def __init__(self):
        self.head = None

    def push(self, v):
        self.head = Node(v, self.head)

l = List()
l.push(1)
l.push(2)
l.push(3)
l.visualize()
\end{minted}
\end{listing}

\begin{figure}[htb]
    \centering
    \includegraphics[width=\linewidth]{imagenes/ejemplos/ejemplo}
    \caption{Captura de la visualización generada a partir del código~\ref{lst:ejemplo-uso}.}
    \label{fig:visualizacion_ej}
    \centering
\end{figure}

Para registrar las operaciones primitivas sobre la estructura de datos el decorador \textit{node} modifica los campos pasados como parámetros para que al momento de acceder o asignar a estos campos se registre la operación en el \textit{logger}.

El \textit{logger} es un objeto que mantiene el registro de las operaciones primitivas sobre la estructura de datos. Además, se puede utilizar como un \textit{context manager} (objetos de Python que definen un contexto y se utilizan con \texttt{with}) y dentro del scope introducido todas las operaciones serán registradas en este \textit{logger}. En el código~\ref{lst:ejemplo-logger-ctx-mgr} se puede ver un ejemplo de esta funcionalidad.

\begin{listing}[htb]
\caption{Ejemplo de uso del \textit{logger} como un \textit{context manager}.}
\label{lst:ejemplo-logger-ctx-mgr}
\begin{minted}[linenos=true]{python}
from dsvisualizer import logger

with Logger() as logger:
    n = Node(5, Node(10, Node(20, None)))
logger.visualize()

with logger:
    n = Node(10, n)
logger.visualize()
\end{minted}
\end{listing}

Cuando se aplica el decorador \textit{container} a una clase, se crea un Logger asociado a cada instancia de esa clase y para todos los métodos de esa clase se utiliza ese logger como \textit{context manager} para que las operaciones sobre la estructura de datos queden registradas en el logger del contenedor.

Esta parte originalmente se implementó usando herencia en vez de decoradores, pero se cambió debido a que de esta manera eran menores los cambios que el usuario debía hacer a su programa para permitirle usar la herramienta.

\section{Front-end}

Como la librería registra las operaciones primitivas no es trivial generar una visualización a partir del modelo, ya que las operaciones registradas no necesariamente representan una operación estándar sobre listas. De hecho estas operaciones definen un grafo dirigido con un grado máximo de 1. Esta representación resulta útil porque permite representar implementaciones incorrectas de una lista enlazada.

Para visualizar por separado las componentes conexas del grafo se deben encontrar los subgrafos conexos a partir de esta representación. En la literatura existen varios algoritmos para resolver este problema, pero por simplicidad se decidió acotar la librería al caso donde el grafo es acíclico, es decir, un bosque. De esta manera, todos los nodos que no tienen ningún arco que apunte a ellos son puntos de entrada. Además, todos estos puntos de entrada definen una lista conexa que no tiene conexiones con otras listas. Entonces, podemos visualizar cada una de estas componentes conexas como una lista.

Para generar la animación se visualiza en orden cada operación primitiva que se obtiene del \textit{front-end} (animándola o no dependiendo de los metadatos de la operación). Para cada operación primitiva primero se obtienen las listas conexas usando el algoritmo descrito previamente, luego se genera una lista donde cada elemento tiene la información asociada a un nodo y finalmente usando D3js se anima la transición desde la versión previa de esta lista hasta la actual.

Los datos asociados a cada nodo son: el índice de la lista a la que pertenece, el largo de la lista a la que pertenece, su índice dentro de la lista a la que pertenece, su identificador único y su valor.

Teniendo la lista, usando D3js se asocian los nodos de la visualización a cada elemento en esta lista usando el identificador del elemento. La animación tiene dos fases: primero se anima la actualización de los nodos existentes y luego se anima la entrada de nuevos nodos.

En la primera fase se transiciona con una animación desde la posición anterior de los nodos a la posición dada por los datos actualizados asociados a cada nodo y se actualizan los valores que hayan cambiado. En la segunda fase se hace un \textit{fade in} de los nuevos nodos en las posiciones correspondientes. Es importante el orden de estas fases porque si se hace en otro orden los nodos entrantes podrían aparecer detrás de nodos preexistentes.

\section{Integración Continua y Entrega Continua}

Para que la herramienta pueda ser utilizada instalándola con el administrador de paquetes de Python se publicó en el repositorio oficial del administrador de paquetes de Python, PyPi (Python Package Index)\footnote{El paquete de PyPi se encuentra disponible en \url{https://pypi.org/project/dsvisualizer/}}. Adicionalmente, cómo el front-end de la herramienta está implementado en TypeScript también fue necesario publicar un paquete en el repositorio NPM (Node Package Manager)\footnote{El paquete de NPM se encuentra disponible en \url{https://www.npmjs.com/package/jupyter-dsvisualizer}}.

En el caso de Python generar el paquete es relativamente sencillo, porque solo utiliza el código definido en el archivo \texttt{setup.py}. En cambio, en el caso del TypeScript esto involucra el uso de una serie de herramientas. Algunas de estas herramientas son: el compilador de TypeScript (TSC) para el chequeo de tipos y la generación del código en JavaScript; y Webpack para generar \textit{bundles} minimizadas a partir del código en JavaScript obtenido de TSC. La generación de \textit{bundles} minimizadas es importante porque reduce el tamaño del paquete que tiene que instalar el usuario, lo que es especialmente relevante cuando este no cuenta con una buena conexión a internet, y porque reduce el tiempo inicial que el navegador se demora en poder ejecutar el código.

Para facilitar el lanzamiento de nuevas versiones de la herramienta el repositorio se encuentra en GitHub y utiliza Github Actions ---una funcionalidad de GitHub que permite ejecutar programas después de eventos como commits o deploys--- para correr las pruebas y para publicar versiones nuevas de la librería.

Cada vez que se agrega un commit al repositorio, una GitHub Action corre los tests y los \textit{linters} de Python (Black) y de JavaScript (Prettier). Además, cuando se hace un release del repositorio otra Github Action compila los paquetes de Python y de JavaScript y los sube a los repositorios de los administradores de paquetes respectivos. Esto permite lanzar nuevas versiones de la herramienta de forma muy expedita, facilitando y acelerando el desarrollo.
